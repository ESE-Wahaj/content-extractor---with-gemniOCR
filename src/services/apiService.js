import { readFileAsArrayBuffer, arrayBufferToBase64 } from '../utils/fileHelpers.js';

// Gemini API Configuration
const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY; 
console.log("Using Gemini API Key:", GEMINI_API_KEY );
// const GEMINI_API_KEY = typeof window.__api_key !== 'undefined' ? window.__api_key : "";
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
const MAX_RETRIES = 5;

// Existing API_CONFIG (for the "Send to API" button logic)
const API_CONFIG = {
  ENABLED: false,
  ENDPOINT: '/api/content/extract',
  TIMEOUT: 30000,
  RETRY_ATTEMPTS: 3
};

/**
 * Calls the Gemini API for multimodal (image/document) analysis with exponential backoff.
 * @param {File} file The file to analyze.
 * @param {string} prompt The specific user prompt/instruction for the AI.
 * @param {function(string)} onProgress Callback for progress updates.
 * @returns {Promise<string>} The AI-generated text response.
 */
export const callGeminiAPI = async (file, prompt, onProgress) => {
    onProgress?.('Preparing file for AI transmission (Base64 encoding)...');
    
    const arrayBuffer = await readFileAsArrayBuffer(file);
    const base64Data = arrayBufferToBase64(arrayBuffer);
    const mimeType = file.type || 'application/octet-stream';

    const parts = [
        {
            inlineData: {
                mimeType: mimeType,
                data: base64Data
            }
        },
        { text: prompt }
    ];

    const payload = {
        contents: [{ parts }],
        // System instruction to specialize the AI for extraction tasks
        systemInstruction: {
            parts: [{ text: "You are an expert Optical Character Recognition (OCR) and image analysis AI. Your sole task is to extract all plain, complete text content from the provided file (image or document) in English. This includes printed text, handwriting, and text on signs/objects. Return only the raw, extracted text, without summarization or commentary." }]
        },
    };

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
            onProgress?.(`Sending data to Gemini API (Attempt ${attempt + 1}/${MAX_RETRIES})...`);

            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                const result = await response.json();
                return result.candidates?.[0]?.content?.parts?.[0]?.text || "No content generated by AI.";
            } else if (response.status === 429 && attempt < MAX_RETRIES - 1) {
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                const errorData = await response.json();
                throw new Error(`API Request failed with status ${response.status}: ${errorData.error.message}`);
            }
        } catch (error) {
            if (attempt === MAX_RETRIES - 1) {
                throw error;
            }
        }
    }
    throw new Error("Failed to connect to the Gemini API after all retries.");
};


// --- Existing API Service for "Send to API" button ---

export const sendToAPI = async (data) => {
  if (!API_CONFIG.ENABLED) {
    console.log('API is disabled. Data would be sent to:', API_CONFIG.ENDPOINT);
    return { success: true, message: 'API is disabled in config' };
  }
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.TIMEOUT);
    
    const response = await fetch(API_CONFIG.ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data),
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    throw new Error(`API error: ${error.message}`);
  }
};

export const prepareAPIPayload = (file, extractedContent) => {
  return {
    filename: file.name,
    fileType: file.type,
    fileSize: file.size,
    extractedContent: extractedContent,
    timestamp: new Date().toISOString(),
    metadata: {
      processingDate: new Date().toISOString(),
      contentLength: extractedContent.length
    }
  };
};